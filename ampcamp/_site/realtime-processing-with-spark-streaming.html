<!DOCTYPE html>
<!--[if lt IE 7]>      <html class="no-js lt-ie9 lt-ie8 lt-ie7"> <![endif]-->
<!--[if IE 7]>         <html class="no-js lt-ie9 lt-ie8"> <![endif]-->
<!--[if IE 8]>         <html class="no-js lt-ie9"> <![endif]-->
<!--[if gt IE 8]><!-->
<html class="no-js" xmlns="http://www.w3.org/1999/html"> <!--<![endif]-->
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <title>Stream Processing w/ Spark Streaming</title>
        <meta name="description" content="">

        <!--<link rel="stylesheet" href="css/vendor/bootstrap/bootstrap.min.css">-->
        <link rel="stylesheet" href="css/vendor/bootstrap/bootstrap.css">
        <meta name="viewport" content="width=device-width">
        <!--<link rel="stylesheet" href="css/vendor/bootstrap/bootstrap-responsive.min.css">-->
        <link rel="stylesheet" href="css/vendor/bootstrap/bootstrap-responsive.css">
        <link rel="stylesheet" href="css/vendor/font-awesome.min.css">
        <!--[if IE 7]>
        <link rel="stylesheet" href="assets/css/vendorfont-awesome-ie7.min.css">
        <![endif]-->
        <link rel="stylesheet" href="css/main.css">

        <script src="js/vendor/modernizr-2.6.1-respond-1.1.0.min.js"></script>

         <!-- prettify js and CSS, used for code highlighting -->
        <link rel="stylesheet" href="css/vendor/prettify/prettify.css" type="text/css" />
        <script src="js/vendor/prettify/prettify.js" type="text/javascript"></script>
        <script src="js/vendor/prettify/lang-scala.js" type="text/javascript"></script>
        <script src="js/vendor/prettify/lang-sql.js" type="text/javascript"></script>
        <script type="text/javascript">

          var _gaq = _gaq || [];
          _gaq.push(['_setAccount', 'UA-33205054-1']);
          _gaq.push(['_trackPageview']);

          (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
          })();

        </script>

    </head>
    <body>
        <!--[if lt IE 7]>
            <p class="chromeframe">You are using an outdated browser. <a href="http://browsehappy.com/">Upgrade your browser today</a> or <a href="http://www.google.com/chromeframe/?redirect=true">install Google Chrome Frame</a> to better experience this site.</p>
        <![endif]-->


        <div class="bar topbar">
            
<a class="btn page-nav" disabled="disable" style="float:left">

  <i class="icon-arrow-left icon-2x"></i>
</a>

            
<a class="btn page-nav" disabled="disable" style="float:right" href="#">

  <i class="icon-arrow-right icon-2x"></i>
</a>

            <a href="http://ampcamp.berkeley.edu/ampcamp3-exercises/" id="ampcamp-logo"></a>
            <!--<img src="img/amplab-small.png" alt="AMP Camp Logo" width="150" id="amplab-logo"/>-->
            <div id="topbar-middle">
                <div class="site-title">Hands-on Exercises</div>
                <div class="btn-group">
                    <div class="btn btn-med dropdown-toggle pull-right" data-toggle="dropdown">
                        Stream Processing w/ Spark Streaming &nbsp; <i class="icon-list-ul icon"></i>
                    </div>
                  <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
                    

  <li>
    
      
    
    <a href="index.html">Introduction</a>
  </li>

  <li>
    
      
    
    <a href="logging-into-the-cluster.html">Logging into the Cluster</a>
  </li>

  <li>
    
      
    
    <a href="overview-of-the-exercises.html">Overview Of The Exercises</a>
  </li>

  <li>
    
      
    
    <a href="introduction-to-the-scala-shell.html">Introduction to the Scala Shell</a>
  </li>

  <li>
    
      
      
    
    <a href="data-exploration-using-spark.html">  1. Data Exploration Using Spark</a>
  </li>

  <li>
    
      
      
    
    <a href="data-exploration-using-shark.html">  2. Data Exploration Using Shark</a>
  </li>

  <li>
    
      
      
    
    <a href="realtime-processing-with-spark-streaming.html">  3. Stream Processing w/ Spark Streaming</a>
  </li>

  <li>
    
      
      
    
    <a href="blinkdb.html">  4. Data Exploration Using BlinkDB</a>
  </li>

  <li>
    
      
      
    
    <a href="mli-document-categorization.html">  5. Machine Learning With MLI</a>
  </li>

  <li>
    
      
      
    
    <a href="mesos.html">  6. Mesos - Cluster & Framework Mgmt</a>
  </li>

  <li>
    
      
    
    <a href="where-to-go-from-here.html">Where to Go From Here</a>
  </li>


                  </ul>
                </div>
            </div>
        </div><!--topbar-->
        <div class="container" id="content">
            
            <div id="chapter-toc" class="chapter-toc"></div>
            
            <p>In this chapter, we will walk you through using Spark Streaming to process live data streams. Remember, Spark Streaming is a component of Spark that provides highly scalable, fault-tolerant streaming processing. These exercises are designed as standalone Scala programs which will receive and process Twitter&#8217;s real sample tweet streams. For the exercises in this section, you can choose to use Scala or Java. If you would like to use Scala but are not familiar with the language, we recommend that you see the <a href="introduction-to-the-scala-shell.html">Introduction to the Scala Shell</a> section to learn some basics.</p>

<h2 id="setup">Setup</h2>
<p>This section will first introduce you to the basic system setup of the standalone Spark Streaming programs, and then guide you through the steps necessary to create Twitter authentication tokens necessary for processing Twitter&#8217;s real time sample stream.</p>

<h3 id="system-setup">System Setup</h3>

<p>We use a modified version of the Scala standalone project template introduced in the <a href="data-exploration-using-spark.html#running-standalone-spark-programs">Running Standalone Spark Programs</a> section for the next exercise. In your AMI, this has been setup in <code>/root/streaming/</code>. You should find the following items in the directory.</p>

<div class="sidebar">
<p style="font-size:1.2em"><b>What is SBT?</b></p>
Simple Build Tool, or SBT, is popular open-source a build tool for Scala and Java projects, written in Scala. Currently, Spark can be built using SBT or Maven, while Spark Streaming an Shark can be built with SBT only. Read more about SBT at <a href="https://github.com/harrah/xsbt/wiki" target="_blank">its Github page</a>.
</div>

<ul>
  <li><code>twitter.txt:</code> File containing Twitter authentication details</li>
  <li>For Scala users
    <ul>
      <li><code>scala/sbt:</code> Directory containing the SBT tool</li>
      <li><code>scala/build.sbt:</code> SBT project file</li>
      <li><code>scala/Tutorial.scala:</code> Main Scala program that you are going to edit, compile and run</li>
      <li><code>scala/TutorialHelper.scala:</code> Scala file containing few helper functions for <code>Tutorial.scala</code></li>
    </ul>
  </li>
  <li>For Java users
    <ul>
      <li><code>java/sbt:</code> Directory containing the SBT tool</li>
      <li><code>java/build.sbt:</code> SBT project file</li>
      <li><code>java/Tutorial.java</code> Main Java program that you are going to edit, compile and run</li>
      <li><code>java/TutorialHeler.java:</code> Java file containing a few helper functions</li>
      <li><code>java/ScalaHelper.java:</code> Scala file containing a few helper functions</li>
    </ul>
  </li>
</ul>

<p>The main file you are going to edit, compile and run for the exercises is <code>Tutorial.scala</code> or <code>Tutorial.java</code>. It should look as follows:</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>import spark._
import spark.streaming._
import StreamingContext._
import TutorialHelper._

object Tutorial {
  def main(args: Array[String]) {

    // Location of the Spark directory
    val sparkHome = "/root/spark"

    // URL of the Spark cluster
    val sparkUrl = getSparkUrl()

    // Location of the required JAR files
    val jarFile = "target/scala-2.9.3/tutorial_2.9.3-0.1-SNAPSHOT.jar"

    // HDFS directory for checkpointing
    val checkpointDir = TutorialHelper.getHdfsUrl() + "/checkpoint/"

    // Configure Twitter credentials using twitter.txt
    TutorialHelper.configureTwitterCredentials()

    // Your code goes here
  }
}
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>import spark.api.java.*;
import spark.api.java.function.*;
import spark.streaming.*;
import spark.streaming.api.java.*;
import twitter4j.*;
import java.util.Arrays;
import scala.Tuple2;

public class Tutorial {
  public static void main(String[] args) throws Exception {
    // Location of the Spark directory
    String sparkHome = "/root/spark";

    // URL of the Spark cluster
    String sparkUrl = TutorialHelper.getSparkUrl();

    // Location of the required JAR files
    String jarFile = "target/scala-2.9.3/tutorial_2.9.3-0.1-SNAPSHOT.jar";

    // HDFS directory for checkpointing
    String checkpointDir = TutorialHelper.getHdfsUrl() + "/checkpoint/";

    // Twitter credentials from login.txt
    TutorialHelper.configureTwitterCredentials()

    // Your code goes here
  }
}
</code></pre>
  </div>
</div>

<p>For your convenience, we have added a couple of helper function to get the parameters that the exercises need.</p>

<ul>
  <li><code>getSparkUrl()</code> is a helper function that fetches the Spark cluster URL from the file <code>/root/spark-ec2/cluster-url</code>.</li>
  <li><code>configureTwitterCredential()</code> is another helper function that configures Twitter&#8217;s authentication detail using the file <code>/root/streaming/twitter.txt</code>. This is explained further in the next section.</li>
</ul>

<h3 id="twitter-credential-setup">Twitter Credential Setup</h3>

<p>Since all of the exercises are based on Twitter&#8217;s sample tweet stream, it is necessary to configure OAuth authentication with a Twitter account. To do this, you will need to setup a consumer key+secret pair and an access token+secret pair using a Twitter account. Please follow the instructions below to setup these temporary access keys with your Twitter account. These instructions will not require you to provide your Twitter username/password. You will only be required to provide the consumer key and access token pairs that you will generate, which you can easily destroy once you have finished the tutorial. So, your Twitter account will not be compromised in any way.</p>

<ol>
  <li>
    <p>Open this <a href="https://dev.twitter.com/apps" target="_blank">link</a>.
This page lists the set of Twitter-based applications that you own and have
already created consumer keys and access tokens for.  This list will be
empty if you have never created any applications. For this tutorial, create
a new temporary application. To do this, click on the blue &#8220;Create a new
application&#8221; button. The new application page should look the page shown
below. Provide the required fields. The <strong>Name</strong> of the application must be
globally unique, so using your Twitter username as a prefix to the name
should ensure that. For example, set it as [your-twitter-handle]-test. For
the <strong>Description</strong> , anything is fine. For the <strong>Website</strong> , similarly, any
website is fine, but ensure that it is a fully-formed URL with the prefix
http:// . Then, click on the &#8220;Yes, I agree&#8221; checkbox below the <strong>Developer
Rules of the Road</strong> . Finally, fill in the CAPTCHA and click on the blue
&#8220;Create your Twitter application&#8221; button.</p>

    <p><img src="img/oauth-2.png" alt="Setting up new application" /></p>
  </li>
  <li>
    <p>Once you have created the application, you will be presented with
a confirmation page similar to the one shown below. You should be able to
see the consumer key and the consumer secret that have been generated. To
generate the access token and the access token secret, click on the blue
&#8220;Create my access token&#8221; button at the bottom of the page (lower green arrow
in the figure below). Note that there will be a small green confirmation at
the top of the page saying that the token has been generated.</p>

    <p><img src="img/oauth-3.png" alt="New application confirmation" /></p>
  </li>
  <li>
    <p>To get all of the keys and secrets required for authentication, click on the
<em>OAuth Tool</em> tab in the top menu on the page (upper green arrow in the
previous figure). You will be presented with a page similar to the one shown
below:</p>

    <p><img src="img/oauth-4.png" alt="OAuth details" /></p>
  </li>
  <li>
    <p>Finally, update the twitter configuration file using your favorite text editor:</p>

    <pre><code>cd /root/streaming/
vim twitter.txt
</code></pre>

    <p>You should see the follow template of = separated key-value pairs already setup.</p>

    <pre><code>consumerKey =
consumerSecret =
accessToken =
accessTokenSecret =
</code></pre>

    <p>Please copy the values from the previous webpage into this appropriate keys in this file. After copying, it should look something like the following:</p>

    <pre><code>consumerKey = z25xt02zcaadf12 ...
consumerSecret = gqc9uAkjla13 ...
accessToken = 8mitfTqDrgAzasd ...
accessTokenSecret = 479920148 ...
</code></pre>

    <p>Please double-check that the right values have been assigned to the right keys. Save the file and proceed to writing your first Spark Streaming program.</p>
  </li>
  <li>
    <p><strong>Once you have finished this tutorial (not now!)</strong>, you can go back to the <a href="https://dev.twitter.com/apps" target="_blank">starting page</a> and delete the application you have created. To do this click on the application, and then click on <em>Delete</em> as shown by the arrow below. This will automatically invalidate the tokens.</p>

    <p><img src="img/oauth-5.png" alt="Delete application" /></p>
  </li>
</ol>

<h2 id="first-spark-streaming-program">First Spark Streaming program</h2>
<p>Let&#8217;s try to write a very simple Spark Streaming program that prints a sample of the tweets it receives from Twitter every second. First locate the
<code>Tutorial</code> class and open it with a text editor.</p>

<div class="codetabs">
<div data-lang="scala">
<pre class="prettyprint lang-bsh">
cd /root/streaming/scala/
vim Tutorial.scala
</pre>
</div>
<div data-lang="java">
<pre class="prettyprint lang-bsh">
cd /root/streaming/java/
vim Tutorial.java
</pre>
</div>
</div>

<p>The cluster machines have both vim and emacs installed for editing. Alternatively, you can use your favorite text editor locally and then copy-paste content using vim or emacs before running it.</p>

<p>To express any Spark Streaming computation, a StreamingContext object needs to be created.
This object serves as the main entry point for all Spark Streaming functionality.</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>    val ssc = new StreamingContext(sparkUrl, "Tutorial", Seconds(1), sparkHome, Seq(jarFile))
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>    JavaStreamingContext ssc = new JavaStreamingContext(
      sparkUrl, "Tutorial", new Duration(1000), sparkHome, new String[]{jarFile});
</code></pre>
  </div>
</div>

<p>Here, we create a StreamingContext object by providing the Spark cluster URL, the batch duration we&#8217;d like to use for streams, the Spark home directory, and the list of JAR files that are necessary to run the program. &#8220;Tutorial&#8221; is a unique name given to this application to identify it the Spark&#8217;s web UI. We elect for a batch duration of 1 second. Next, we use this context to create a stream of tweets:</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>    val tweets = ssc.twitterStream()
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>    JavaDStream&lt;Status&gt; tweets = ssc.twitterStream();
</code></pre>
  </div>
</div>

<p>The object <code>tweets</code> is a DStream of tweet statuses. More specifically, it is continuous stream of RDDs containing objects of type <a href="http://twitter4j.org/javadoc/twitter4j/Status.html">twitter4j.Status</a>. As a very simple processing step, let&#8217;s try to print the status text of the some of the tweets.</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>    val statuses = tweets.map(status =&gt; status.getText())
    statuses.print()
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>    JavaDStream&lt;String&gt; statuses = tweets.map(
      new Function&lt;Status, String&gt;() {
        public String call(Status status) { return status.getText(); }
      }
    );
    statuses.print();
</code></pre>
  </div>
</div>

<p>Similar to RDD transformation in the earlier Spark exercises, the <code>map</code>
operation on <code>tweets</code> maps each Status object to its text to create a new
&#8216;transformed&#8217; DStream named <code>statuses</code>. The <code>print</code> output operation tells the
context to print first 10 records in each RDD in a DStream, which in this case
are 1 second batches of received status texts.</p>

<p>We also need to set an HDFS for periodic checkpointing of the intermediate data.</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>    ssc.checkpoint(checkpointDir)
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>    ssc.checkpoint(checkpointDir);
</code></pre>
  </div>
</div>

<p>Finally, we need to tell the context to start running the computation we have setup.</p>

<div class="codetabs">
<div data-lang="scala">
    <pre><code>    ssc.start()
</code></pre>
  </div>
<div data-lang="java">
    <pre><code>    ssc.start();
</code></pre>
  </div>
</div>

<p><strong>Note that all DStream operations must be done before calling this statement.</strong></p>

<p>After saving <code>Tutorial.scala</code>, it can be run from the command prompt using the following command (from within the <code>/root/streaming/[language]</code> directory).</p>

<pre><code>sbt/sbt package run</code></pre>

<p>This command will automatically compile the <code>Tutorial</code> class and create a JAR file in <code>/root/streaming/[language]/target/scala-2.9.2/</code>. Finally, it will run the program. You should see output similar to the following on your screen:</p>

<pre class="nocode">
-------------------------------------------
Time: 1359886325000 ms
-------------------------------------------
RT @__PiscesBabyyy: You Dont Wanna Hurt Me But Your Constantly Doing It
@Shu_Inukai ?????????????????????????????????????????
@Condormoda Us vaig descobrir a la @080_bcn_fashion. Molt bona desfilada. Salutacions des de #Manresa
RT @dragon_itou: ?RT???????3000???????????????????????????????????10???????

?????????????????2?3???9???? #???? http://t.co/PwyA5dsI ? h ...
Sini aku antar ke RSJ ya "@NiieSiiRenii: Memang (?? ?`? )"@RiskiMaris: Stresss"@NiieSiiRenii: Sukasuka aku donk:p"@RiskiMaris: Makanya jgn"
@brennn_star lol I would love to come back, you seem pretty cool! I just dont know if I could ever do graveyard again :( It KILLs me
????????????????????????????????????????????????????????????????????????????????????????ww
??????????
When the first boats left the rock with the artificers employed on.
@tgs_nth ????????????????????????????
...


-------------------------------------------
Time: 1359886326000 ms
-------------------------------------------
???????????
???????????
@amatuki007 ????????????????????????????????
?????????????????
RT @BrunoMars: Wooh!
Lo malo es qe no tiene toallitas
Sayang beb RT @enjaaangg Piye ya perasaanmu nyg aku :o
Baz? ?eyler yar??ma ya da reklam konusu olmamal? d???ncesini yenemiyorum.
?????????????MTV???????the HIATUS??
@anisyifaa haha. Cukupla merepek sikit2 :3
@RemyBot ?????????
...
</pre>

<p>To stop the application, use <code>Ctrl + c</code> .</p>

<p><strong>FAQ</strong>: If you see the following message, it means that the authentication with Twitter failed.</p>

<pre class="nocode">
13/02/04 23:41:57 INFO streaming.NetworkInputTracker: De-registered receiver for network stream 0 with message 401:Authentication credentials (https://dev.twitter.com/pages/auth) were missing or incorrect. Ensure that you have set valid consumer key/secret, access token/secret, and the system clock is in sync.
&lt;html&gt;
&lt;head&gt;
&lt;meta http-equiv="Content-Type" content="text/html; charset=utf-8"/&gt;
&lt;title&gt;Error 401 Unauthorized&lt;/title&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h2&gt;HTTP ERROR: 401&lt;/h2&gt;
&lt;p&gt;Problem accessing '/1.1/statuses/sample.json?stall_warnings=true'. Reason:
&lt;pre&gt;    Unauthorized&lt;/pre&gt;



&lt;/body&gt;
&lt;/html&gt;


Relevant discussions can be found on the Internet at:
	http://www.google.co.jp/search?q=d0031b0b or
	http://www.google.co.jp/search?q=1db75513
TwitterException{exceptionCode=[d0031b0b-1db75513], statusCode=401, message=null, code=-1, retryAfter=-1, rateLimitStatus=null, version=3.0.3}
</pre>

<p><strong>Answer:</strong> Please verify whether the Twitter consumer key+secret and access token+secret has been set correctly in the file <code>twitter.txt</code> as instructed earlier.</p>

<h2 id="further-exercises">Further exercises</h2>
<p>Next, let&#8217;s try something more interesting, say, try printing the 10 most popular hashtags in the last 5 minutes. These next steps explain the set of the DStream operations required to achieve our goal. As mentioned before, the operations explained in the next steps must be added in the program before <code>ssc.start()</code>. After every step, you can see the contents of new DStream you created by using the <code>print()</code> operation and running Tutorial in the same way as explained earlier (that is, <code>sbt/sbt package run</code>).</p>

<ol>
  <li>
    <p><strong>Get the stream of hashtags from the stream of tweets</strong>:
To get the hashtags from the status string, we need to identify only those words in the message that start with &#8220;#&#8221;. This can be done as follows:</p>

    <div class="codetabs">
<div data-lang="scala">

        <pre><code>    val words = statuses.flatMap(status =&gt; status.split(" "))
    val hashtags = words.filter(word =&gt; word.startsWith("#"))
</code></pre>

      </div>
<div data-lang="java">

        <pre><code>   JavaDStream&lt;String&gt; words = statuses.flatMap(
     new FlatMapFunction&lt;String, String&gt;() {
       public Iterable&lt;String&gt; call(String in) {
         return Arrays.asList(in.split(" "));
       }
     }
   );

   JavaDStream&lt;String&gt; hashTags = words.filter(
     new Function&lt;String, Boolean&gt;() {
       public Boolean call(String word) { return word.startsWith("#"); }
     }
   );
</code></pre>

      </div>
</div>

    <p>The <code>flatMap</code> operation applies a one-to-many operation to each record in a DStream and then flattens the records to create a new DStream.
In this case, each status string is split by space to produce a DStream where each record is a word.
Then we apply the <code>filter</code> function to retain only the hashtags. The resulting <code>hashtags</code> DStream is a stream of RDDs having only the hashtags.
If you want to see the result, add <code>hashtags.print()</code> and try running the program.
You should see something like this (assuming no other DStream has <code>print</code> on it):</p>

    <pre class="nocode">
-------------------------------------------
Time: 1359886521000 ms
-------------------------------------------
#njnbg
#njpw
#?????
#algeria
#Annaba
</pre>
  </li>
  <li>
    <p><strong>Count the hashtags over a 5 minute window</strong>: Next, we&#8217;d like to count these hashtags over a 5 minute moving window.
A simple way to do this would be to gather together the last 5 minutes of data and process it in the usual map-reduce way &#8212; map each tag to a (tag, 1) key-value pair and
then reduce by adding the counts. However, in this case, counting over a sliding window can be done more intelligently. As the window moves, the counts of the new data can
be added to the previous window&#8217;s counts, and the counts of the old data that falls out of the window can be &#8216;subtracted&#8217; from the previous window&#8217;s counts. This can be
done using DStreams as follows:</p>

    <div class="codetabs">
<div data-lang="scala">

        <pre><code>    val counts = hashtags.map(tag =&gt; (tag, 1))
                         .reduceByKeyAndWindow(_ + _, _ - _, Seconds(60 * 5), Seconds(1))
</code></pre>

        <p>The <code>_ + _</code> and <code>_ - _</code> are Scala shorthands for specifying functions to add and subtract two numbers. <code>Seconds(60 * 5)</code> specifies
the window size and <code>Seconds(1)</code> specifies the movement of the window.</p>

      </div>
<div data-lang="java">

        <pre><code>   JavaPairDStream&lt;String, Integer&gt; tuples = hashTags.map(
      new PairFunction&lt;String, String, Integer&gt;() {
        public Tuple2&lt;String, Integer&gt; call(String in) {
          return new Tuple2&lt;String, Integer&gt;(in, 1);
        }
      }
    );

    JavaPairDStream&lt;String, Integer&gt; counts = tuples.reduceByKeyAndWindow(
      new Function2&lt;Integer, Integer, Integer&gt;() {
        public Integer call(Integer i1, Integer i2) { return i1 + i2; }
      },
      new Function2&lt;Integer, Integer, Integer&gt;() {
        public Integer call(Integer i1, Integer i2) { return i1 - i2; }
      },
      new Duration(60 * 5 * 1000),
      new Duration(1 * 1000)
    );
</code></pre>

        <p>There are two functions that are being defined for adding and subtracting the counts. <code>new Duration(60 * 5 * 1000)</code>
specifies the window size and <code>new Duration(1 * 1000)</code> specifies the movement of the window.</p>

      </div>
</div>

    <p>Note that only &#8216;invertible&#8217; reduce operations that have &#8216;inverse&#8217; functions (like how subtraction is the inverse of addition)
can be optimized in this manner. The generated <code>counts</code> DStream will have records that are (hashtag, count) tuples.
If you <code>print</code> counts and run this program, you should see something like this:</p>

    <pre class="nocode">
-------------------------------------------
Time: 1359886694000 ms
-------------------------------------------
(#epic,1)
(#WOWSetanYangTerbaik,1)
(#recharged,1)
(#??????????,1)
(#jaco,1)
(#Blondie,1)
(#TOKIO,1)
(#fili,1)
(#jackiechanisamazing,1)
(#DASH,1)
...
</pre>
  </li>
  <li>
    <p><strong>Find the top 10 hashtags based on their counts</strong>:
Finally, these counts have to be used to find the popular hashtags.
A simple (but not the most efficient) way to do this is to sort the hashtags based on their counts and
take the top 10 records. Since this requires sorting by the counts, the count (i.e., the second item in the
(hashtag, count) tuple) needs to be made the key. Hence, we need to first use a <code>map</code> to flip the tuple and
then sort the hashtags. Finally, we need to get the top 10 hashtags and print them. All this can be done as follows:</p>

    <div class="codetabs">
<div data-lang="scala">
        <pre><code>    val sortedCounts = counts.map { case(tag, count) =&gt; (count, tag) }
                             .transform(rdd =&gt; rdd.sortByKey(false))
    sortedCounts.foreach(rdd =&gt;
      println("\nTop 10 hashtags:\n" + rdd.take(10).mkString("\n")))
</code></pre>
      </div>
<div data-lang="java">
        <pre><code>   JavaPairDStream&lt;Integer, String&gt; swappedCounts = counts.map(
     new PairFunction&lt;Tuple2&lt;String, Integer&gt;, Integer, String&gt;() {
       public Tuple2&lt;Integer, String&gt; call(Tuple2&lt;String, Integer&gt; in) {
         return in.swap();
       }
     }
   );

   JavaPairDStream&lt;Integer, String&gt; sortedCounts = swappedCounts.transform(
     new Function&lt;JavaPairRDD&lt;Integer, String&gt;, JavaPairRDD&lt;Integer, String&gt;&gt;() {
       public JavaPairRDD&lt;Integer, String&gt; call(JavaPairRDD&lt;Integer, String&gt; in) throws Exception {
         return in.sortByKey(false);
       }
     });

   sortedCounts.foreach(
     new Function&lt;JavaPairRDD&lt;Integer, String&gt;, Void&gt; () {
       public Void call(JavaPairRDD&lt;Integer, String&gt; rdd) {
         String out = "\nTop 10 hashtags:\n";
         for (Tuple2&lt;Integer, String&gt; t: rdd.take(10)) {
           out = out + t.toString() + "\n";
         }
         System.out.println(out);
         return null;
       }
     }
   );
</code></pre>
      </div>
</div>

    <p>The <code>transform</code> operation allows any arbitrary RDD-to-RDD operation to be applied to each RDD of a DStream to generate a new DStream.
The resulting &#8216;sortedCounts&#8217; DStream is a stream of RDDs having sorted hashtags.
The <code>foreach</code> operation applies a given function on each RDD in a DStream, that is, on each batch of data. In this case,
<code>foreach</code> is used to get the first 10 hashtags from each RDD in <code>sortedCounts</code> and print them, every second.
If you run this program, you should see something like this:</p>

    <pre class="nocode">
Top 10 hashtags:
(2,#buzzer)
(1,#LawsonComp)
(1,#wizkidleftEMEcos)
(1,#???????)
(1,#NEVERSHUTMEUP)
(1,#reseteo.)
(1,#casisomoslamismapersona)
(1,#job)
(1,#????_??_?????_??????)
(1,#?????RT(*^^*))
</pre>

    <p>Note that there are more efficient ways to get the top 10 hashtags. For example, instead of sorting the entire of
5-minute-counts (thereby, incurring the cost of a data shuffle), one can get the top 10 hashtags in each partition,
collect them together at the driver and then find the top 10 hashtags among them.
We leave this as an exercise for the reader to try.</p>
  </li>
  <li>
    <p><strong>API Reference</strong>: You can explore the full streaming API by referencing the <a href="http://www.cs.berkeley.edu/~pwendell/strataconf/api/streaming/index.html#spark.streaming.DStream">Java/Scala</a> API docs.</p>
  </li>
</ol>

        </div> <!-- /container -->


        <div class="bar bottombar">
            
<a class="btn page-nav" disabled="disable" style="float:left">

  <i class="icon-arrow-left icon-2x"></i>
</a>

            
<a class="btn page-nav" disabled="disable" style="float:right" href="#">

  <i class="icon-arrow-right icon-2x"></i>
</a>

          <div class="btn-group dropup">
            <a class="btn btn-med" target="_blank" href="https://github.com/amplab/training/issues">
              <i class="icon-exclamation-sign"> </i>
              Submit an issue on GitHub
            </a>
          </div>
            <div class="btn-group dropup">
                <div class="btn btn-med dropdown-toggle" data-toggle="dropdown">
                    Stream Processing w/ Spark Streaming &nbsp; <i class="icon-list-ul icon"></i>
                </div>
                <ul class="dropdown-menu" role="menu" aria-labelledby="dropdownMenu">
                    

  <li>
    
      
    
    <a href="index.html">Introduction</a>
  </li>

  <li>
    
      
    
    <a href="logging-into-the-cluster.html">Logging into the Cluster</a>
  </li>

  <li>
    
      
    
    <a href="overview-of-the-exercises.html">Overview Of The Exercises</a>
  </li>

  <li>
    
      
    
    <a href="introduction-to-the-scala-shell.html">Introduction to the Scala Shell</a>
  </li>

  <li>
    
      
      
    
    <a href="data-exploration-using-spark.html">  1. Data Exploration Using Spark</a>
  </li>

  <li>
    
      
      
    
    <a href="data-exploration-using-shark.html">  2. Data Exploration Using Shark</a>
  </li>

  <li>
    
      
      
    
    <a href="realtime-processing-with-spark-streaming.html">  3. Stream Processing w/ Spark Streaming</a>
  </li>

  <li>
    
      
      
    
    <a href="blinkdb.html">  4. Data Exploration Using BlinkDB</a>
  </li>

  <li>
    
      
      
    
    <a href="mli-document-categorization.html">  5. Machine Learning With MLI</a>
  </li>

  <li>
    
      
      
    
    <a href="mesos.html">  6. Mesos - Cluster & Framework Mgmt</a>
  </li>

  <li>
    
      
    
    <a href="where-to-go-from-here.html">Where to Go From Here</a>
  </li>


                </ul>
            </div>
            <div class="site-title">Hands-on Exercises</div>
        </div>

        <script src="js/vendor/jquery-1.8.3.min.js"></script>
        <script src="js/vendor/bootstrap.min.js"></script>
        <!-- Table of contents plugin -->
        <script src="js/vendor/toc.js" type="text/javascript"></script>
        <script src="js/main.js"></script>
    </body>
</html>
